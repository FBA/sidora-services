<?xml version="1.0" encoding="UTF-8"?>

<blueprint xmlns="http://www.osgi.org/xmlns/blueprint/v1.0.0"
           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
           xmlns:cm="http://aries.apache.org/blueprint/xmlns/blueprint-cm/v1.1.0"
           xsi:schemaLocation="http://www.osgi.org/xmlns/blueprint/v1.0.0 http://www.osgi.org/xmlns/blueprint/v1.0.0/blueprint.xsd">

    <!--  ActiveMQ destinations to use  -->
    <!--
    We likely want to change to a queue.
    <bean id="destination" class="org.apache.activemq.command.ActiveMQTopic">
        <constructor-arg type="java.lang.String" value="${sidora.broker.topics}"/>
    </bean>
    -->

    <!-- JMS ConnectionFactory to use, configuring the embedded broker using XML -->
    <bean id="connectionFactory" class="org.apache.activemq.spring.ActiveMQConnectionFactory">
        <!-- <property name="brokerURL" value="${broker.url}"/> -->
        <property name="brokerURL" value="tcp://localhost:61616"/>
    </bean>

    <!-- Use a pooled connections for scalability -->
    <bean id="pooledConnectionFactory" class="org.apache.activemq.pool.PooledConnectionFactory" init-method="start" destroy-method="stop">
        <property name="maxConnections" value="8" />
        <property name="connectionFactory" ref="connectionFactory" />
    </bean>

    <!-- Use pooled connections for JMS -->
    <bean id="jmsConfig" class="org.apache.camel.component.jms.JmsConfiguration">
        <property name="connectionFactory" ref="pooledConnectionFactory"/>
        <property name="concurrentConsumers" value="1"/>
        <!-- Until we choose our means of consuming this avoids duplication -->
        <!-- <property name="concurrentConsumers" value="10"/> -->
    </bean>

    <!-- Use the Camel JMS Components for performance and route flexibility -->
    <bean id="jms" class="org.apache.camel.component.jms.JmsComponent">
        <property name="connectionFactory" ref="connectionFactory"/>
    </bean>

    <!-- Use the Camel AMQ component for performance -->
    <bean id="activemq" class="org.apache.activemq.camel.component.ActiveMQComponent">
        <property name="configuration" ref="jmsConfig"/>
    </bean>

    <bean id="modelAggregator" class="edu.smithsonian.services.fedorarepo.aggregators.ContentModelAggregationStrategy"/>
    
    <bean id="contentModels" class="java.util.HashSet"/>

    <!-- Provides the Camel routing setup -->
    <camelContext id="DerivativesCamelContext"
                  xmlns="http://camel.apache.org/schema/blueprint"
                  xmlns:atom="http://www.w3.org/2005/Atom"
                  xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
                  xmlns:fs="info:fedora/fedora-system:def/model#"
                  trace="false">
        
        <route id="DerivativesStartProcessing">
            <from uri="activemq:topic:fedora.apim.update"/>
            <log message="Starting Derivatives processing ..."/>
            <log message="PID: ${headers.pid} Method Name: ${headers.methodName}"/>
            
            <!-- Get the login used by the source of the message, effectively this is the source of the message. -->
            <!-- Do not process messages coming from other Camel processes -->
            <log message="Fedora User - {{si.fedora.user}}"/>
            <filter>
                <xpath>/atom:entry/atom:author/atom:name != '{{si.fedora.user}}'</xpath>
                <stop/>
            </filter>

            <!-- If its a message type of interest -->
            <to uri="direct:processDerivativesMessage"/>

            <!--
            From the message get the PID and set the CamelFedoraPid header.
            We need to know whether the method in the message is one for which we need to pay attention
            We need to get the source login so we can ignore messages from ingest routes
            We need to know the content models for sure either from the triplestore or the FDO (faster)
            -->
            <log message="${body}"/>
            <log message="Finished Derivatives processing!"/>
        </route>
        
        <route id="DerivativesProcessMessage">
            <from uri="direct:processDerivativesMessage"/>
            <log message="Starting Derivatives Message processing ..."/>
            
            <!-- Get the PID of the FDO that was just operated upon. -->
            <log message="PID: ${headers.pid} Method Name: ${headers.methodName}"/>
            <setHeader headerName="CamelFedoraPid"><simple>${headers.pid}</simple></setHeader>

            <!-- Get the Content Models for the FDO and put them on a list. -->
            <to uri="fedora://getDatastreamDissemination?dsId=RELS-EXT&amp;exchangePattern=InOut"/>
            <log message="Derivatives RELS-EXT: ${body}"/>
            <split strategyRef="modelAggregator">
                <xpath>//fs:hasModel/@rdf:resource</xpath>
                <log message="Split Content Model - ${body}"/>
            </split>

            <choice>
                <when>
                    <spel>"#{request.headers[ContentModels].contains('info.fedora/si:cameraTrapCModel')}"</spel>
                    <log message="Handle Camera Trap"/>
                </when>
            </choice>

            <log message="Content Models - ${header.ContentModels}"/>
            <log message="Finished Derivatives Message processing!"/>
        </route>

    </camelContext>
    
</blueprint>
