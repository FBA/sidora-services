<?xml version="1.0" encoding="UTF-8"?>

<blueprint xmlns="http://www.osgi.org/xmlns/blueprint/v1.0.0"
           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
           xmlns:cm="http://aries.apache.org/blueprint/xmlns/blueprint-cm/v1.1.0"
           xsi:schemaLocation="http://www.osgi.org/xmlns/blueprint/v1.0.0 http://www.osgi.org/xmlns/blueprint/v1.0.0/blueprint.xsd">

    <!--  ActiveMQ destinations to use  -->
    <!--
    We likely want to change to a queue.
    <bean id="destination" class="org.apache.activemq.command.ActiveMQTopic">
        <constructor-arg type="java.lang.String" value="${sidora.broker.topics}"/>
    </bean>
    -->

    <!-- JMS ConnectionFactory to use, configuring the embedded broker using XML -->
    <bean id="connectionFactory" class="org.apache.activemq.spring.ActiveMQConnectionFactory">
        <!-- <property name="brokerURL" value="${broker.url}"/> -->
        <property name="brokerURL" value="tcp://localhost:61616"/>
    </bean>

    <!-- Use a pooled connections for scalability -->
    <bean id="pooledConnectionFactory" class="org.apache.activemq.pool.PooledConnectionFactory" init-method="start" destroy-method="stop">
        <property name="maxConnections" value="8" />
        <property name="connectionFactory" ref="connectionFactory" />
    </bean>

    <!-- Use pooled connections for JMS -->
    <bean id="jmsConfig" class="org.apache.camel.component.jms.JmsConfiguration">
        <property name="connectionFactory" ref="pooledConnectionFactory"/>
        <property name="concurrentConsumers" value="1"/>
        <!-- Until we choose our means of consuming this avoids duplication -->
        <!-- <property name="concurrentConsumers" value="10"/> -->
    </bean>

    <!-- Use the Camel JMS Components for performance and route flexibility -->
    <bean id="jms" class="org.apache.camel.component.jms.JmsComponent">
        <property name="connectionFactory" ref="connectionFactory"/>
    </bean>

    <!-- Use the Camel AMQ component for performance -->
    <bean id="activemq" class="org.apache.activemq.camel.component.ActiveMQComponent">
        <property name="configuration" ref="jmsConfig"/>
    </bean>

    <!-- Provides the Camel routing setup -->
    <camelContext id="derivativesCamelContext"
                  xmlns="http://camel.apache.org/schema/blueprint"
                  xmlns:atom="http://www.w3.org/2005/Atom"
                  trace="true">
        
        <route id="DerivativesStartProcessing">
            <from uri="activemq:topic:fedora.apim.update"/>
            <log message="Starting Derivatives processing ..."/>
            <log message="PID: ${headers.pid} Method Name: ${headers.methodName}"/>
            <setHeader headerName="changeAuthor">
                <xpath resultType="java.lang.String">/atom:entry/atom:author/atom:name</xpath>
            </setHeader>
            <log message="PID: ${headers.pid} Method Name: ${headers.methodName} Author: ${headers.changeAuthor}"/>

            <!--
            From the message get the PID and set the header.
            We need to know the method is one for which we need to pay attention
            We need to know the content models for sure either from the triplestore or the FDO (the faster)
            If the object we need to pluck them from RELS-EXT
            We also need to correlate a Fedora message resulting from a Camel-operation vs a UI operation to prevent
            loops. Best choice for now is the Author which is linked to the process login.
            <to uri="fedora://getDatastreamDissemination?dsId=RELS-EXT"/>
            -->
            <log message="${body}"/>
            <log message="Finished Derivatives processing!"/>
        </route>

    </camelContext>
    
</blueprint>
